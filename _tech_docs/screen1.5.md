以下、海外の資料を基に日本語でまとめ直したが、いわゆる日本で理解されているスクリーン1.5とは異なる模様。
技術的には面白いのでドキュメントとしては残しておく。

----------

「SCREEN 1.5」（MSX Graphics Mode 1.5）は、**標準のBIOSで定義されたスクリーンモードではありません**。
これは、プログラマーがVDP（Video Display Processor）のレジスタを直接操作することによって実現される、**Graphic Mode 2 (SCREEN 2) の設定に、Graphic Mode 1 (SCREEN 1) のVRAMアクセスの利点を組み合わせたハイブリッドな設定**です,。

### SCREEN 1.5とはなにか

SCREEN 1.5は、MSX1世代のVDPであるTMS9918AのVRAMアーキテクチャの根本的な制約を回避するために、ハードウェアレジスタレベルで実装された**非常に特殊なテクニカルパッチ**として理解されています。

このモードの核心は、VDPのレジスタ操作を通じて**VRAMアドレスに意図的な重複（オーバーラップ）を発生させる**ことです,。

1.  **モード設定**: Graphic Mode 2（SCREEN 2）と同じモード選択ビット（VDPレジスタR#0およびR#1）を設定し、256x192の解像度と8x1ピクセルラインごとの色解像度のロジックを維持します。
2.  **VRAMアドレスの操作**: 通常、Graphic Mode 2では、パターンジェネレーターテーブル（PGT）は$0000H$から、カラーテーブル（CT）は$2000H$から始まるように、VDPレジスタR#4とR#3がそれぞれ異なる値に設定されます,。
3.  **オーバーラップ**: SCREEN 1.5では、**カラーテーブルのアドレス（R#3）とパターンジェネレーターテーブルのアドレス（R#4）の両方を同じ値（一般的には$00$）に設定します**。これにより、パターンデータとカラー属性データの両方が$0000H$から始まる**同じ物理的なVRAM領域**から取得されます,。

### なにをもって１と２の間なのか

SCREEN 1.5が「1と2の間」とされるのは、以下の要素を組み合わせた結果、中間的な性能とアーキテクチャの特性を持つためです。

| 特性 | Graphic Mode 1 (SCREEN 1) | Graphic Mode 2 (SCREEN 2) | SCREEN 1.5 (Hybrid) |
| :--- | :--- | :--- | :--- |
| **解像度/構造** | 低解像度 (32x24キャラクタ) | **高解像度 (256x192)**、複雑なVRAM構造 | **高解像度 (256x192)**、タイルの構造を維持 |
| **VRAMデータ配置** | 統一的で線形（シンプル） | **断片化**（PGTとCTが$0000H$と$2000H$に分離） | **論理的に統一的**（PGTとCTを単一ブロックに結合）, |
| **Z80アクセス効率** | 高速な線形メモリアクセス | VRAMアドレス再設定のオーバーヘッドが大きい | **Screen 1に近い線形メモリアクセス速度** |

つまり、**Screen 2の持つ高解像度とタイル構造を維持**しながら、**Screen 1の持つようなシンプルで高速なVRAMアクセス効率**を実現している点が、「1と2の間」である所以です。

### その用途は

SCREEN 1.5の主な用途は、MSX1ハードウェアの制約を克服し、**高速なグラフィック処理**を実現することにあります。

1.  **高速なマップスクロールとアニメーション**:
    MSX1にはハードウェアスクロール機能がないため、スムーズなスクロールはCPU（Z80）がVRAM内のタイルデータ（PGT/CT）を絶えず書き換えるソフトウェア処理に依存します。標準のScreen 2では、パターンデータ（$0000H$）とカラーデータ（$2000H$）が分離しているため、Z80はデータの転送中にVDPのアドレスレジスタを再プログラムしてアドレス範囲を切り替える必要があり、これが大きなボトルネックとなります,。
    SCREEN 1.5では、PGTとCTのデータが単一の連続したブロック（例：$0000H$から$17FFH$）に統合されるため、Z80は**LDIR命令**などの最速のブロック転送命令を使用して、**VDPアドレスポートを中断して再設定することなく**、数キロバイトのデータを一度に転送できます,。これにより、ソフトウェアによるマップの高速更新と、よりスムーズなスクロールが可能になります,。

2.  **VRAM領域の最大活用**:
    MSX1の16KB VRAMという限られたリソースにおいて、この技術は標準のScreen 2で必須だった**VRAMの$2000H$セグメントをカラーテーブルに使用する必要をなくします**,。これにより、$2000H$以降のセグメントが、ゲームアセットや高速バッファとして利用できる**連続した大きな空きメモリブロック**として解放されます,。

要するに、SCREEN 1.5は、VDPのVRAMアドレス指定の断片化という設計上の弱点に、レジスタ操作による「裏技」で対処することで、**Z80のデータ転送効率を最大限に高め**、MSX1で高性能なゲームを実現するために考案されました。

はい、承知いたしました。SCREEN 1.5の設定方法とVRAM構成について、ソースに基づいてご説明します。

SCREEN 1.5は、標準のBIOSモードではなく、**Graphic Mode 2 (SCREEN 2) の高解像度（256x192）と、Graphic Mode 1 (SCREEN 1) のような効率的なVRAMアクセスを両立させるために、プログラマーがVDPレジスタを直接操作して実現するハイブリッドな設定**です,。

### 1. VDPレジスタの設定（モード1.5のアクティベーション）

SCREEN 1.5は、Graphic Mode 2の表示ロジックを維持しつつ、カラーテーブルとパターンジェネレーターテーブルのアドレスを意図的に重複させることで実現されます。

この設定で特に重要となるのは、モード制御レジスタ（R#0、R#1）とVRAMテーブルベースアドレスレジスタ（R#3、R#4）です。

| VDPレジスタ (ID) | 機能 | SCREEN 2 (標準) | **SCREEN 1.5 (ハイブリッド)** |
| :--- | :--- | :--- | :--- |
| **R#0 (M3)** | モード制御レジスタ 0 | Bit 1 = 1 | **Bit 1 = 1** |
| **R#1 (M4, M1)** | モード制御レジスタ 1 | Bits 4, 6 = 1, 1 | **Bits 4, 6 = 1, 1** |
| **R#3** | カラーテーブル (CT) ベースアドレス | $A0 (Base $2000H)$ | **$00 または $80 (PGTと重複)**, |
| **R#4** | パターンジェネレーターテーブル (PGT) ベースアドレス | $00 (Base $0000H)$ | **$00 または $80 (CTと重複)**, |

**中心となる操作**は、**R#3 (カラーテーブルアドレス)** と **R#4 (パターンジェネレーターテーブルアドレス)** の両方を**同じ値**（一般的には VRAM の $0000H$ セグメントを指す **$00$**）に設定することです。

標準のSCREEN 2では、R#3は$2000H$を指すように設定されますが、SCREEN 1.5ではこれを$0000H$に強制的に重ねることで、VDPがカラー情報とパターン情報を同じ物理メモリ領域からフェッチするように仕向けます,,。

### 2. スクリーン1.5の具体的なVRAM構成

このレジスタ操作の結果、VRAM内の主要なテーブルの配置は、標準のSCREEN 2で強制されていた**断片化が解消され、統合された構造**となります,。

標準のSCREEN 2では、パターンジェネレーターテーブル（PGT）とカラーテーブル（CT）はVRAM内の**異なるセグメント**（$0000H$と$2000H$）に分離されていましたが、SCREEN 1.5では以下のようになります。

| VRAM要素 | 必要なサイズ | SCREEN 2 (標準アドレス) | **SCREEN 1.5 (最適化されたアドレス)** |
| :--- | :--- | :--- | :--- |
| **パターンジェネレーターテーブル (PGT)** | 6 KB | $0000H - $17FFH | **$0000H - $17FFH** |
| **パターンネームテーブル (PNT)** | 768 B | $1800H - $1AFFH | **$1800H - $1AFFH** |
| **カラーテーブル (CT)** | 6 KB | $2000H - $37FFH$ | **PGT領域と重複（$0000H$から論理的に）** |

#### カラーとパターンの統合（重複）

統合のメカニズムは以下の通りです。

1.  **単一ブロックへの結合**: PGTとCTのデータは、VRAMの先頭から**単一の連続したブロック**（$0000H$から$17FFH$まで、合計6KB）に格納されます,。
2.  **VDPの動作**: VDPはGraphic 2のロジックに従い、ピクセルデータ（パターン）とカラー属性データ（カラー）の両方を、R#3とR#4が指す**同じベースアドレス**（$0000H$）からフェッチし続けます。
3.  **高速化の理由**: この「論理的な統合」により、Z80 CPUは、マップスクロールなどでタイルデータ（パターンとカラーの両方）を更新する際、VDPのアドレスレジスタを$0000H$から$2000H$に切り替えるための**高コストなI/O操作を回避できます**,。代わりに、Z80はVDPの書き込みアドレスを$0000H$に一度設定した後、Z80の最速のブロック転送命令である`LDIR`を使用して、**中断なしに連続した6KBのPGT/CTデータをVRAMに転送**できます,。

この結果、プログラマーは標準のScreen 2の分離された構造（独立したカラー定義の柔軟性）を犠牲にする代わりに、Z80のデータ転送効率を劇的に向上させ、スムーズなソフトウェアスクロールなどの動的なグラフィック更新を実現できるのです,。

また、標準のScreen 2で必須だったVRAMの**$2000H$セグメントを使用しない**ため、この領域はMSX1の16KB VRAMシステムにおいて、ゲームアセットや高速バッファとして利用可能な**連続した大きな空きメモリブロック**として解放されます,。


-----


SCREEN 1.5は、MSX1のVDP (TMS9918A) の制約を回避するために、Graphic Mode 2の設定とVRAMアドレス指定のオーバーラップを利用して、**高速なVRAMブロック転送**を可能にするための技術です,。

以下に、Z80アセンブリ言語でSCREEN 1.5を初期化し、VRAMのパターン/カラー領域を一部書き換えるコード例を示します。

### Z80アセンブリコード例（SCREEN 1.5初期化とVRAM書き込み）

この例では、MSX1/MSX2で一般的なVDPポートアドレス（データポート $98H$、コマンドポート $99H$）を使用し、VDPレジスタR#3とR#4を**意図的に$00H$に設定して重複させる**ことでSCREEN 1.5モードを実現しています,。

```assembly
; MSX VDP I/Oポートアドレス
VDP_DAT EQU 98H     ; VRAMデータポート (n')
VDP_CMD EQU 99H     ; VDPコマンド/レジスタポート (n' + 1)
SCREEN_WIDTH EQU 32
SCREEN_HEIGHT EQU 24

; Z80 RAM上のデータ領域
ORG 8000H           ; ユーザープログラム開始アドレス
START:
    CALL INIT_SCREEN1_5 ; 1. SCREEN 1.5を初期化

    ; 2. VRAMへタイルパターン/カラーデータを書き込む
    ; 例として、VRAMアドレス 0000H (PGT/CT領域の先頭) に8バイトのデータ（1タイル分）を転送する
    LD HL, TILE_DATA    ; Z80 RAM上の転送元アドレス
    CALL VRAM_WRITE_TILE
    
    ; 3. PNT (Name Table) を更新し、タイルを表示する
    ; PNTの先頭 (VRAM $1800H$) に、書き込んだタイルコード 0 を設定する
    LD HL, $1800H       ; PNTのVRAMアドレス
    LD BC, 1            ; 1バイト転送
    LD A, 0             ; タイルコード 0 (書き込んだばかりのパターン)
    CALL PNT_SET_TILE

LOOP:
    JR LOOP             ; 停止

; ======================================================
; サブルーチン 1: SCREEN 1.5 初期化
; ======================================================
INIT_SCREEN1_5:
    ; VDPレジスタ書き込みの前にはDIを必須とする (BIOS割り込みによる妨害防止)
    DI

    ; R#0: $02H (M3=1, Graphic Mode 2のロジック維持)
    LD A, $02H      
    OUT (VDP_CMD), A
    LD A, $80 | 0   ; R#0 選択 (Bit 7 = 1)
    OUT (VDP_CMD), A

    ; R#1: $D2H (16K RAM, Blank ON, IE=1, M2=1, Graphic Mode 2のロジック維持)
    LD A, $D2H      
    OUT (VDP_CMD), A
    LD A, $80 | 1   ; R#1 選択
    OUT (VDP_CMD), A

    ; R#3: $00H (カラーテーブルベースを 0000H に設定)
    LD A, $00H      
    OUT (VDP_CMD), A
    LD A, $80 | 3   ; R#3 選択
    OUT (VDP_CMD), A

    ; R#4: $00H (パターンジェネレーターベースを 0000H に設定) -> R#3とR#4が重複し、SCREEN 1.5が成立
    LD A, $00H      
    OUT (VDP_CMD), A
    LD A, $80 | 4   ; R#4 選択
    OUT (VDP_CMD), A

    ; R#7: $1FH (ボーダーカラー/キャラクタカラー設定例)
    LD A, $1FH      
    OUT (VDP_CMD), A
    LD A, $80 | 7   ; R#7 選択
    OUT (VDP_CMD), A

    ; R#2: $03H (パターンネームテーブル PNTを VRAM $1800H に設定)
    LD A, $03H      
    OUT (VDP_CMD), A
    LD A, $80 | 2   ; R#2 選択
    OUT (VDP_CMD), A

    EI              ; 割り込みを有効に戻す
    RET

; ======================================================
; サブルーチン 2: VRAMへパターン/カラーデータ（1タイル分）を書き込む
; HL: 転送元アドレス (Z80 RAM)
; VRAMアドレスは 0000H に固定して使用する
; ======================================================
VRAM_WRITE_TILE:
    ; VDPアドレスカウンターを 0000H (LSB $00, MSB $00) に設定し、書き込みモードを有効化
    DI
    LD A, $00H      ; LSB: A0-A7
    OUT (VDP_CMD), A

    LD A, $00H      ; MSB: A8-A13
    OR $40H         ; 書き込みフラグ (Bit 6 = 1) を立てる
    OUT (VDP_CMD), A

    ; 転送実行: PGT/CT領域の先頭 8バイトに連続して書き込む
    LD C, VDP_DAT   ; Cレジスタにデータポートアドレス $98H をセット
    LD B, 8         ; 転送バイト数 (1タイル分のパターン8バイト + カラー8バイト... ではない)
                    ; スクリーン1.5ではパターンとカラーが同じ領域に統合されるため、
                    ; ここではPGT/CTが統合されたデータ構造の先頭8バイトを書き込むと仮定する。
                    ; (1タイルは8バイトのパターンデータと8バイトのカラーデータで構成されるため、
                    ; 通常、高速転送時には16バイトの連続データを転送するが、ここでは例として8バイトに限定する)

    LD B, 16        ; 実際にはパターン8バイトとカラー8バイトの計16バイトを転送することが多い
    
    OTIR            ; HLからVDPデータポート(C)へBバイトを転送し、VDPアドレスを自動インクリメント

    EI
    RET

; ======================================================
; サブルーチン 3: PNT (Pattern Name Table) を書き換える
; HL: 転送先VRAMアドレス
; BC: 転送バイト数 (ここでは1)
; A: 書き込むタイルコード
; ======================================================
PNT_SET_TILE:
    ; VDPアドレスカウンターを HL に設定し、書き込みモードを有効化
    PUSH BC         ; B, Cレジスタを保存
    PUSH AF         ; A, Fレジスタを保存
    
    LD E, L
    LD D, H         ; VRAMアドレス HL を DE にコピー

    ; VRAMアドレス設定 (MSX1 VDPではR#14がないため、14ビットアドレスのみ設定)
    DI
    LD A, E         ; LSB (A0-A7)
    OUT (VDP_CMD), A

    LD A, D         ; MSB (A8-A13)
    OR $40H         ; 書き込みフラグ (Bit 6 = 1) を立てる
    OUT (VDP_CMD), A

    POP AF          ; 書き込むタイルコードをAに戻す
    
    ; VRAMへ書き込み
    OUT (VDP_DAT), A

    POP BC          ; BCを復元
    EI
    RET

; ======================================================
; データ定義
; ======================================================
TILE_DATA:
; 16バイトのデータ例 (パターン8バイト + カラー8バイト)
; PGT/CTが重複しているため、VDPは$0000Hからパターンデータを読み取り、
; その後、カラーテーブルとして$0000Hからのデータも読み取る
; したがって、この16バイトのブロックは、パターンデータとカラーデータが混在する形となる
; (注: 厳密なSCREEN 1.5のPGT/CTの論理的配置は複雑だが、ここでは連続したデータブロックとして扱う)
    DB 0FFH, 0AAH, 0FFH, 0AAH, 0FFH, 0AAH, 0FFH, 0AAH ; パターンデータ (例: 8x8のチェック柄)
    DB 4EH, 4EH, 4EH, 4EH, 4EH, 4EH, 4EH, 4EH         ; カラーデータ (例: 前景色=4(Dark Blue), 背景色=14(Gray) -> 4EH)
```

### コードの解説

1.  **モード設定（`INIT_SCREEN1_5`）**:
    *   このルーチンは、VDPレジスタR#0およびR#1をGraphic Mode 2 (SCREEN 2) と同じ設定にします,。
    *   **R#3とR#4の重複**: R#3 (カラーテーブルベース) と R#4 (パターンジェネレーターベース) の両方に**$00H**を設定します,。これにより、VDPはパターンデータとカラー属性データの両方をVRAMの**$0000H$**から始まる同じ物理領域から読み取るようになり、SCREEN 1.5のアーキテクチャが確立します,。

2.  **VRAMアドレス設定（`VRAM_WRITE_TILE` / `PNT_SET_TILE`）**:
    *   CPUがVRAMにアクセスする際は、まずVDPのアドレスカウンターを設定する必要があります。これは、アドレスの下位バイト（LSB）を$99H$（コマンドポート）に出力し、次にアドレスの上位バイト（MSB）を$99H$に出力することで行われます,。
    *   MSBを送信する際、**Bit 6を$1$（$40H$を論理和）**にすることで、VDPを**書き込みモード**に設定します,。
    *   Z80のI/O操作中は、MSXの割り込みハンドラによるVDPステータスレジスタの読み出しを防ぐため、**`DI`（割り込み禁止）**と**`EI`（割り込み許可）**で処理を囲むことが極めて重要です,。

3.  **高速VRAM転送（`OTIR`）**:
    *   SCREEN 1.5の最大の利点は、パターンデータとカラーデータが$0000H$から始まる**連続したブロック**としてVRAMに配置されることです,。
    *   これにより、Z80は**`OTIR`**（Output and Increment and Repeat）命令を使用して、数キロバイトのデータを中断なくVRAMデータポート（$98H$）にストリーム転送できます,。標準のSCREEN 2のように途中でVDPアドレスレジスタを再設定する高コストなI/O操作が不要になるため、マップスクロールなどの動的なグラフィック更新が劇的に加速されます,。
    *   この例では、`OTIR`命令は、HLが指すZ80 RAM上の`TILE_DATA`から16バイトをVDPデータポート（Cレジスタ）に高速で転送しています。


